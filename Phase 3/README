# Real-Time Trading System (Phase 3) â€“ C++ Implementation

This document provides an overview of the real-time trading system implemented in **Phase 3**, including code structure, memory management approach, and instructions to compile and run the system. The implementation emphasizes **memory safety** by using modern C++ practices (RAII and smart pointers) and a clean separation of concerns.

## Architecture Overview

The trading system is organized into modular components:

- **MarketSnapshot** (`market_snapshot.h/cpp`): Maintains the current market state (order book) with bids and asks. Each price level is represented by a `PriceLevel` struct. The `MarketSnapshot` class stores bids and asks in sorted maps (bids in descending order, asks in ascending order) using `std::unique_ptr<PriceLevel>` for each entry. It provides methods to update price levels (adding/updating or removing when quantity is zero) and to fetch the best bid and ask.
- **OrderManager** (`order_manager.h/cpp`): Tracks orders submitted by our trading strategy. Each order is represented by a `MyOrder` struct (containing order ID, side, price, quantity, and filled amount). Orders are stored in a map of `orderId -> unique_ptr<MyOrder>`. The `OrderManager` provides methods to place new orders, cancel existing orders, and handle execution fills (updates order fill quantity and removes the order when fully filled). It ensures orders are managed with RAII, so memory is freed when orders are completed or canceled.
- **Trading Strategy & Main Loop** (`main.cpp`): The `main` function ties everything together. It reads a simulated market data feed (from `sample_feed.txt` or standard input), uses `MarketSnapshot` to update the order book for each feed event, and implements a simple trading strategy that places orders based on market conditions. It also processes execution events from the feed by updating the `OrderManager`. All components are integrated to run in real-time (in this simulation, as a fast loop over the feed lines) with proper resource management.

## Memory Management and Safety (RAII)

Memory safety is a key design goal. The implementation uses **smart pointers** and RAII principles to eliminate manual memory management:

- **Market data (PriceLevel)**: `MarketSnapshot` dynamically allocates each `PriceLevel` (to store price and quantity for a given level) and holds it in a `std::unique_ptr`. When a price level is removed (e.g., quantity goes to zero), the unique pointer is erased from the map, automatically freeing the `PriceLevel` memory. Similarly, when `MarketSnapshot` is destroyed (at program end), all remaining `PriceLevel` objects are freed by their unique_ptr owners. This prevents any memory leaks in managing the order book.
- **Orders**: The `OrderManager` uses `std::unique_ptr<MyOrder>` for each tracked order. When an order is fully executed or canceled, the corresponding unique_ptr is removed from the map, and the allocated `MyOrder` is freed. At program termination, any still-active orders (if any) are cleaned up by the `OrderManager` destructor or via an explicit cancel-all. This ensures no dangling orders or memory leaks.
- **RAII**: Resources are tied to object lifetimes. There are no raw `new` or `delete` calls in the code; all dynamic memory is handled by containers and smart pointers. This minimizes the risk of memory errors (like double frees or leaks) and makes the code easier to maintain and reason about. The use of RAII means that as soon as an object (price level or order) is no longer needed, its destructor frees the resource automatically.

The design also cleanly separates concerns: Market data updates and order management are independent. They interact in `main.cpp` but do not directly depend on each other's internal implementations. This makes the system easier to extend and less error-prone.

## Build and Installation (Cross-Platform)

This project is standard C++17 and has no external dependencies, so it can be compiled on multiple platforms (Linux, macOS, Windows). Below are instructions for Windows using Cygwin (or MinGW) with g++, as well as using Microsoft Visual C++:

**Using Cygwin/MinGW (g++):**
1. Ensure you have a C++17-capable compiler installed (e.g., g++ from Cygwin or MinGW, or clang).
2. Navigate to the project directory containing the source files (`market_snapshot.cpp`, `order_manager.cpp`, `main.cpp`) and headers.
3. Compile the code using g++. For example, in Cygwin terminal:
   ```bash
   g++ -std=c++17 -Wall -Wextra -O2 market_snapshot.cpp order_manager.cpp main.cpp -o trading_system.exe
